{
  "tool": "code2logic",
  "target_project": "test-broken-code",
  "tokens_in": 186424,
  "tokens_out": 2961,
  "duration_analysis_sec": 10.647916316986084,
  "duration_llm_sec": 234.18838810920715,
  "duration_total_sec": 244.8384439945221,
  "context_chars": 678048,
  "raw_code_chars": 2790515,
  "compression_ratio": 0.757016894730901,
  "llm_response": " Based on the AST and function logic provided, here is a comprehensive code review of the `test-broken-code` project:\n\n## 1. Security Concerns (Critical)\n\n### SQL Injection Vulnerability\n**Location**: `app/config.py`, `app/logging_pipeline.py`, `app/analytics.py`, `app/auth.py`, `app/db.py`, `app/etl.py`, `app/inventory.py`, `app/orders.py`, `app/payments.py`, `app/recommendations.py`, `app/utils.py`, `app/api.py`  \n**Function**: `unsafe_sql_lookup(conn:Any, table:str, user_input:str)`\n\n- **Issue**: Direct concatenation of `user_input` into SQL queries via `conn.execute.fetchall` and `conn.execute`\n- **Risk**: Attackers can execute arbitrary SQL commands\n- **Fix**: Use parameterized queries: `conn.execute(\"SELECT * FROM ? WHERE id = ?\", (table, user_input))`\n\n### Code Injection Vulnerability\n**Location**: All 15 app modules listed above  \n**Function**: `insecure_eval(expression:str)`\n\n- **Issue**: Direct use of `eval()` on user-provided strings\n- **Risk**: Remote code execution (RCE) vulnerability\n- **Fix**: Replace with `ast.literal_eval()` for safe evaluation, or use a proper expression parser like `simpleeval`\n\n## 2. Bugs & Logic Errors\n\n### Mutable Default Argument Bug (State Leakage)\n**Location**: All 15 app modules  \n**Functions**: \n- `accumulate(values:list[int], acc:list[int]=[])` \n- `generated_rule_0` through `generated_rule_219` (all 220 functions with `cache:dict[str,Any]={}`)\n\n- **Issue**: Mutable default arguments (`[]` and `{}`) are evaluated once at function definition time, causing state to persist across calls\n- **Impact**: \n  - `accumulate` will incorrectly accumulate values from previous calls\n  - All `generated_rule_*` functions share the same cache dictionary across invocations\n- **Fix**: Use `None` as default and initialize inside function:\n  ```python\n  def accumulate(values: list[int], acc: list[int] | None = None) -> list[int]:\n      if acc is None:\n          acc = []\n      # ... rest of logic\n  ```\n\n### Division by Zero\n**Location**: All 15...",
  "llm_quality_keywords": 21,
  "error": null,
  "metadata": {
    "parser": "tree-sitter",
    "format": "compact+function_logic"
  }
}