{
  "tool": "callgraph",
  "target_project": "/project",
  "tokens_in": 1471,
  "tokens_out": 2333,
  "duration_analysis_sec": 2.044560670852661,
  "duration_llm_sec": 52.87570548057556,
  "duration_total_sec": 54.92559289932251,
  "context_chars": 4841,
  "raw_code_chars": 2790515,
  "compression_ratio": 0.9982651947758747,
  "llm_response": " Based on this call graph analysis, I've identified several critical architectural issues, security risks, and massive code duplication. Here is my detailed review:\n\n## 1. Critical Code Duplication & Architecture Violations\n\n**Issue:** The `app.analytics` module contains **162+ generated functions** (`generated_rule_0` through `generated_rule_115+`) with **identical call signatures**.\n\n**Evidence:**\n- Every function calls: `get` (4×), `int` (2×), `str` (1×) in identical patterns\n- 1,274 call edges with repetitive structure suggests copy-paste or auto-generated boilerplate\n\n**Impact:**\n- **Maintenance nightmare**: Bug fixes require editing 162+ locations\n- **Binary bloat**: Unnecessary function definitions increase memory footprint\n- **Testing burden**: Impossible to unit test each rule individually\n\n**Recommendation:**\nRefactor to a **data-driven rule engine**:\n\n```python\n# Instead of 162 functions:\nRULES_CONFIG = {\n    'rule_0': {'extract': ['field_a', 'field_b'], 'convert': ['int', 'int'], 'output': 'str'},\n    # ... 161 more entries\n}\n\ndef evaluate_rule(rule_id, data):\n    config = RULES_CONFIG[rule_id]\n    # Single implementation point\n```\n\n## 2. Data Flow & Validation Issues\n\n**Issue:** Unsafe type conversion chain without validation.\n\n**Evidence:**\n```\ngenerated_rule_X -> get -> int\ngenerated_rule_X -> get -> int\n```\n\n**Bugs Identified:**\n- **`int()` conversion without validation**: If `get` returns `None` (missing key) or non-numeric string, this raises `ValueError`/`TypeError`\n- **No default values**: `get` likely refers to `dict.get()`, but no default handling before conversion\n- **Silent failures**: If `get` is HTTP `requests.get()`, network failures aren't handled before conversion\n\n**Recommendation:**\nAdd a validation layer:\n\n```python\ndef safe_int_convert(value, rule_id, field_name):\n    if value is None:\n        raise ValidationError(f\"Missing required field {field_name} in {rule_id}\")\n    try:\n        return int(value)\n    except (ValueError, TypeErro...",
  "llm_quality_keywords": 21,
  "error": null,
  "metadata": {
    "nodes": 2834,
    "edges": 18712,
    "entry_points": 0
  }
}