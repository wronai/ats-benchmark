{
  "tool": "nfo",
  "target_project": "/project",
  "tokens_in": 41950,
  "tokens_out": 2545,
  "duration_analysis_sec": 0.1864767074584961,
  "duration_llm_sec": 144.18799233436584,
  "duration_total_sec": 144.3789005279541,
  "context_chars": 160307,
  "raw_code_chars": 2790515,
  "compression_ratio": 0.9425528979417778,
  "llm_response": " Based on the NFO representation, this codebase exhibits severe architectural anti-patterns, security vulnerabilities, and logic errors. Here's the detailed analysis:\n\n## 1. Critical Security Concerns\n\n### SQL Injection (Critical)\n- **Function**: `unsafe_sql_lookup()` in **all modules** (`app/db.py`, `app/auth.py`, `app/api.py`, etc.)\n- **Issue**: Function name indicates raw SQL construction without parameterization\n- **Recommendation**: Replace with parameterized queries using SQLAlchemy or `sqlite3` parameterized statements. Never concatenate user input into SQL.\n\n### Remote Code Execution (Critical)\n- **Function**: `insecure_eval()` in **all modules**\n- **Issue**: Likely uses Python's `eval()` on untrusted input\n- **Recommendation**: Replace with `ast.literal_eval()` for safe parsing, or use JSON schema validation. If dynamic code execution is required, implement a sandboxed environment with restricted builtins.\n\n### Unsafe Deserialization\n- **Function**: `parse_payload()` in **all modules**\n- **Issue**: Returns `dict[str, Any]` with no validation; likely parses external input without schema validation\n- **Recommendation**: Implement Pydantic models or marshmallow schemas to validate all incoming payloads before processing.\n\n## 2. Bugs & Logic Errors\n\n### Division by Zero / Incorrect Average\n- **Function**: `broken_average()` → `float` (present in all modules)\n- **Issue**: Name suggests incorrect calculation; likely fails on empty lists or uses integer division\n- **Evidence**: Test `test_broken_average_single_value()` exists specifically for this\n- **Recommendation**: Add empty list guard: `return sum(items) / len(items) if items else 0.0`\n\n### State Leakage Between Calls\n- **Function**: `accumulate()` → `list[int]`\n- **Issue**: Test `test_accumulate_should_not_leak_state()` indicates mutable default arguments or static state\n- **Recommendation**: Initialize accumulators inside function scope, not as default parameters:\n  ```python\n  def accumulate(items: list[in...",
  "llm_quality_keywords": 22,
  "error": null,
  "metadata": {
    "mode": "data_flow+runtime",
    "has_runtime_logs": false
  }
}