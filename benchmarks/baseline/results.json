{
  "tool": "baseline-raw",
  "target_project": "/project",
  "tokens_in": 54197,
  "tokens_out": 1997,
  "duration_analysis_sec": 0.0010728836059570312,
  "duration_llm_sec": 50.48562240600586,
  "duration_total_sec": 50.49013304710388,
  "context_chars": 232610,
  "raw_code_chars": 2790515,
  "compression_ratio": 0.0,
  "llm_response": " Code Review: `app/analytics.py` & `app/__init__.py`\n\n## 1. Critical Security Vulnerabilities\n\n**`unsafe_sql_lookup(conn, table, user_input)`** (Line ~15)\n- **SQL Injection**: Both `table` and `user_input` are interpolated directly into the query string without parameterization. Attackers can inject SQL via either parameter (e.g., `user_input=\"'; DROP TABLE users; --\"`).\n- **Fix**: Use parameterized queries: `conn.execute(\"SELECT * FROM ? WHERE name = ?\", (table, user_input))`.\n\n**`insecure_eval(expression)`** (Line ~19)\n- **Arbitrary Code Execution**: `eval()` executes arbitrary Python code. This is a critical RCE vulnerability.\n- **Fix**: Replace with `ast.literal_eval()` for literals, or implement a safe math parser (e.g., `simpleeval`).\n\n**Hardcoded Secrets** (All `generated_rule_*` functions, Lines ~50+)\n- 200+ functions contain hardcoded secrets (`secret = \"hardcoded-secret-N\"`). These are rotated through a small set of 17 values (0-16) but exposed in source code.\n- **Fix**: Use environment variables or a secrets manager (e.g., `os.environ.get(\"SECRET\")`).\n\n## 2. Logic Errors & Data Flow Issues\n\n**`broken_average(values)`** (Line ~35)\n- **Off-by-one Error**: Divides by `len(values) - 1` instead of `len(values)`. Crashes with `ZeroDivisionError` when passed a single element list.\n- **Fix**: Change to `len(values)` and handle empty list edge case.\n\n**`accumulate(values, acc=[])`** (Line ~31)\n- **Mutable Default Argument**: The default `acc=[]` is evaluated once at import time, causing state leakage between calls.\n- **Fix**: Use `acc=None` and initialize inside function.\n\n**`parse_payload(raw)`** (Line ~23)\n- **Data Corruption**: Blindly replaces single quotes with double quotes before JSON parsing, corrupting valid JSON strings containing apostrophes (e.g., `\"name\": \"O'Brien\"` becomes invalid JSON).\n- **Fix**: Remove the replacement; handle JSON parsing properly with error handling.\n\n**`generated_rule_*` functions** (Lines ~50 to end)\n- **Division by Zero**: `ra...",
  "llm_quality_keywords": 18,
  "error": null,
  "metadata": {
    "mode": "raw_source"
  }
}